## Verilog的基本语法：

### 思维导图：

![image-20221004111737190](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/img/image-20221004111737190.png)

### 一、基本词法：

#### 1.变量名称：

- 允许使用：字母、数字、下划线、$。注意，只允许使用字母或下划线作为变量名的开头。
- 推荐写法：所有的信号全用小写，所有的宏全部用大写。

#### 2.区分大小写：

- Verilog语言区分大小写，qort和QURT表示不同的含义。

#### 3.注释：

- 单行注释：//......
- 多行注释：/* ...... */

#### 4.转义字符：

- 由于Verilog对字符的描述同样使用ASCII编码，因此同样支持转移字符，和C语言相同。

### 二、逻辑值与常量：

#### 1.逻辑值：

- 0，表示数字电路中的低电平，占位为1bit。
- 1，表示数字电路中的高电平，占位为1bit。
- x，表示数字电路中的未知值或者不关心值。
  - 常用来表示不关心值，因为我们要避免产生未知值。
  - 对哪一位不关心，我们就把哪一位设置为x。
- z，表示数字电路中的高阻态。

#### 2.常量：

- 整形常量：
  - 整形常量是Verilog中使用最多的，因为在描述电路的时候是对每一位进行描述，因此全部都是整数。
  - 普通十进制表述法：
    - 16表示十进制的16，16的存储方式采用的二进制补码。
    - -15表示十进制的-15，-15的存储方式同样采用二进制补码。
  - 基数表述法：
    - 基本格式：``[位宽]'进制符号 数字``
    - 进制符号：``h—16进制``、``o—8进制``、``d—10进制``、``b—二进制``。
    - 8'hFF：表示一个8bit的十六进制数FF，也就是1111，1111。
      - 注意，基数表示的时候，数据中间不掺杂空格。
    - 如果**位宽**比**数字的实际宽度**大，那么自动在多出来的位上补0，注意不满足符号扩展。
    - 如果**位宽**比**数字的实际宽度**小，那么截断数字高位超出的部分。
- 实数常量：
  - 实数在描述电路的时候不常用，实数有两种表述方式。
  - 十进制的普通小数：
    - 1.11
  - 十进制的科学计数法：
    - 1.3e10(表示1.3 x $10^{10}$)
- 字符串：
  - 注意：Verilog字符串和C语言字符串都放在双引号中，唯一的不同是Verilog的字符串不含结尾空字符。
  - 上面的区别本质上是因为Verilog不需要对字符串执行操作，只需要把每一个字符翻译成一字节的ASCII即可。


### 三、模块与文件

- 一般来讲，我们会把模块定义在单个文件中，并且把模块名与文件名写一致。当我们需要某个模块的时候，直接引用这个文件，然后直接实例化就可以。

### 四、编译指令：

#### 1.编译指令标志：

- 在Verilog中，所有的编译指令都用``'反引号``表示，这是与C语言的区别。

#### 2.延时：

- 延时在Verilog电路描述中非常重要。
- 基本格式：``#延时``
- #10，表示延时10个时间单位。
- 重点：遇到延时符号，会把当前语句挂起，延时结束之后在继续执行。

#### 2.'timescale：

例如：'timescale 1ns/100ps

- 这个编译指令定义了**时间单位**和**时间精度**。
- 上面这条指令，时间单位是1ns，时间精度(最小时间)是100ps，即0.1ns。
  - 如果一个延时是：``#1.16``，由于精度是0.1ns，因此``#1.16``等价于``#1.2``，使用``四舍五入规则``。

1、前面我们说过，一般把模块的定义放在一个单独文件中，如果我们在这个文件中定义了时间单位和时间精度，那么这个模块的时间单位和时间精度不会受别的文件影响。

2、如果某个文件中没有定义时间单位和时间精度，那么这个文件中的模块受上一个生效的时间单位和时间精度控制。

#### 3.'define：

- define主要用来定义位宽，使用宏的好处在C语言中就已经体会到了，便于修改和移植。
- 例如：定义一个位宽为16bit的wire总线a:
  - 'define BUS_WIDTH 16
  - wire [BUS_WIDTH -1 : 0] a;**牢记这种定义方式。**

#### 4.'ifdef	'define	'endif	'include

- 这几个编译指令用来像C语言一样创建头文件和引用头文件。

### 五、有符号数和无符号数：

- 区分有符号数和无符号数的意义：
  - 对于存储有符号数的类型，其解码的时候按照有符号数来解码。
  - 对于存储无符号数的类型，其解码的时候按照无符号数来解码。
  - 如果混用的话可能会产生溢出，因此要格外注意。

#### 1.有符号数(补码)：

- integer类型的值。
- 普通十进制常量。

#### 2.无符号数(原始二进制编码)：

- reg类型的值。
- 线网类型变量。
- 基数格式的常量。

### 六、操作符：

#### 1.算数操作符：

- "+"、"—"、"*"、"/"、"%"。
- 和C语言相同。

#### 2.按位操作符(双目运算符)：

- "~按位取反"、"&按位与"、"|按位或"、"^按位异或"、"~^按位异或非"。
- 和C语言相同。

#### 3.归约操作符(单目运算符)：

- 注意：归约操作指的是``对操作数本身``的每一位**从高到底**进行操作，最终结果只有**一位**。
- "&归约与"、"~&归约与非"、"|归约或"、"~|归约或非"、"^归约异或"、"~^归约异或非"。
- 例：二进制的a = 1111 , 0101;&a表示把a的每一bit按从高到低进行与操作，最终结果为0。

#### 4.逻辑操作符：

- "!逻辑取反"、"&&逻辑与"、"||逻辑或"
- 逻辑表达式的值为布尔值，1bit的1或0。
- 逻辑移位操作符：
  - "<<" 左移操作符。
  - ">>" 右移操作符。

#### 5.关系操作符：

- ">"、">="、"<"、"<="、"=="、'"!="、"==="、"!=="
- 注意，上述关系操作符有两个全等操作符："==="、"！=="
  - 相等操作符只能判断0和1两个逻辑值，而全等操作符能够判断0、1、x、z四个逻辑值。
  - 相等操作符两端的操作数如果出现x或z结果一定为不定态x。

![](https://nickaljy-pictures.oss-cn-hangzhou.aliyuncs.com/img/Screenshot from 2022-10-04 15-11-38.png)

#### 6.？操作符：

- expression_0 ？ expression_1 : expression_2
- 如果expression_0为逻辑真(非0)，那么整个表达式的结果为expression_1的值，否则为expression_2的值。

#### 7.位拼接操作符：

- 位拼接操作符是Verilog中非常重要的一个操作符。
- {m,n}，将m和n的位按照先后顺序拼接起来，形成一个位宽更大的信号。
- {4{m}}，表示{m,m,m,m}。
- 位拼接操作符的使用：
  - 位拼接最常用的是进行移位操作和不同位进行拼接的操作，这里不再演示。
  - 可以将信号赋值给位拼接表达式，例如在实现加法器的时候可以简化代码：

```verilog
module addition(in_1 , in_2 , carry_1 , out , carry_2)
    input in_1,in_2,carry_1;
    output	out,carry_2;
    
    assign:{carry_2 , out} = in_1 + in_2 + carry_1;
endmodule
/*
上述代码使用位拼接操作符实现了一个全加器：{carry_2 , out}就相当于一个两位的等待赋值的变量，如果有进位，carry_2所表示的那一位会被赋值为1。
*/	
```

### 七、电路的三种描述方式：

#### 1.数据流描述：

- 数据流描述指的就是assign语句。

- 在assign语句中被赋值的变量只能是线网类型。

- 称为数据流描述的原因：
  - assign语句在电路中和其他语句是并行的，互不影响。
  - assign语句会一直不间断的执行，就像水流一样，不间断的流动，又因为assign描述的是数据信号的关系，因此叫做数据流。

- assign语句：

  - 我们也把assign语句叫做连续赋值语句：assign语句中的操作是一直执行的，像水流一样。
  - assign语句用来描述**简单**的组合逻辑电路，因为默认规定assign语句后面只跟一个表达式。
    - 即：assign:expression;

- 阻塞赋值语句：

  - a = b;这就是一条阻塞赋值语句。

  - 阻塞赋值语句是形成组合逻辑电路的基础，因此描述组合逻辑电路的时候，我们全部使用阻塞赋值语句。

    阻塞赋值的意义是，当前赋值语句的执行会阻塞后面赋值语句的执行，只有当前执行完毕，后面的才能执行，是串行执行的。

  - 在assign语句中，使用=，即阻塞赋值语句。

#### 2.行为描述：

- 在Verilog中，行为描述有两种方式：always和initial。
  - 其中，用在电路实现中的语句只有always语句。

- always语句：
  - 在always语句中被赋值的变量只能是一个寄存器类型。

  - always语句用来描述一个全局时钟，这是仿真中的用途：
    - ``always #10 Clock = ~Clock``
    - 我们来解读上面这一条语句：在0仿真时间的时候，always语句被执行，但是在一开始就遇到了延时，于是always被挂起10个时间单位，之后执行时钟翻转，然后继续执行always......
    - 我们分析一下assign和always的区别：
      - assign的输出严格对应输入，如果没有输入，也就没有输出，就像水流一样。	
      - 而always语句在执行的时候被挂起10个时间单位，这10个时间单位内是没人对时钟赋值的，因此always中的时钟保存了上一次赋值的数据，这也是为什么要求被定义为寄存器类型。
      - 在接下来我们要讨论的用always描述组合逻辑电路和时序逻辑电路一样，当敏感列表中的信号发生改变时，才会执行always语句，否则always语句处于挂起状态。

  - always语句描述一个组合逻辑电路：

    - ```verilog
      always @(a,b,c,d)
      begin
      	......    
      end
      ```

      其中，@后面的括号叫做敏感列表，敏感列表的作用：敏感列表里的任何信号变化都可能会引起电路输出发生改变，那么对于这样的信号，我们就把他放入敏感列表中。

      规定always在描述电路的时候，使用``begin  end``语句块。

    - 在always描述组合逻辑电路的时候，语句块中的赋值语句同样使用阻塞赋值语句。

  - always语句描述一个时序逻辑电路：

    - ```verilog
      always @(posedge clk or negedge res)
      begin
          ......
      end
      ```

      其中，在敏感列表中只写时钟的上升沿、下降沿或者复位信号的上升沿、下降沿。因为时序逻辑电路只与时钟和复位有关。

    - 在always描述时序逻辑电路的时候，语句块中使用非阻塞赋值<=，每个赋值语句之间并行。

      - 疑问点解惑：有人可能会问，``begin end``语句块是顺序执行的，但是``<=``赋值是并行的，那么二者在一起会产生什么样的效果？

        - 其实，``begin end``并不会影响``<=``的并行赋值。

        - ```verilog
          always @(posedge clk)
          begin
          	a <= b;
          	c <= a;
          end
          ```

          1.首先，在语句块中，先顺序计算``<=``右边的值，不立刻执行赋值操作；先计算表达式b的值，然后计算表达式a的值。

          2.当always语句执行完毕之后，会并行的执行赋值操作。

          3.这个例子其实实现了一个二级流水线的数据总线。

- initial语句：

  - 注意：initial语句只用于仿真测试中。
  - initial语句在0仿真时间执行，并且只执行一次

- fork...join语句块：

  - 该语句块中的所有语句并行执行。

#### 3.结构化描述：

- 实例化逻辑门原语：Verilog库中自带的逻辑门。

- 实例化模块(手写+库自带)。

- 无论是逻辑门原语还是模块，实例化操作都是相同的，这很类似C语言中函数调用，直接向函数中传递参数。

  - 对于实例化来讲，向模块中传递信号。

  - ```verilog
    module block(in_1 , in_2 , out)
        ......
    endmodule
        /*
        ......
        */
    block block_1(.in_1(a),.in_2(b),.out(c));
    //我们在一开始定义了一个模块，然后执行了一次实例化，实例化的时候要在端口列表中写清楚信号传递的接口，"." + 模块中的信号名：表示一个端口，括号中表示向该端口传递的信号。
    ```


### 八、基本变量类型：

- 我们目前只讨论常用的wire和reg类型。

- wire型：
  - wire叫做网络数据类型，它表示电路模块中实际的连线，但是在仿真的波形图中不能看到wire类型变量。
  - 如果不规定wire变量的位宽，默认是1bit。
  - 凡是在assign语句中被赋值的变量，一定要被定义为wire类型。
- reg型：
  - reg叫做寄存器类型，reg类型的变量会在仿真波形图中显示。
  - reg变量仅仅是语法的定义，他不等价于电路中的寄存器，只有在时序逻辑中，reg变量才相当于寄存器(可以理解为寄存器的输出端)。
  - 如果不规定reg变量的位宽，默认是1bit。
  - 凡是在always语句、initial语句中被赋值的变量，一定要被定义成reg类型。

### 九、驱动与赋值：

#### 1.驱动：

- 线网变量是被驱动的，执行驱动的这个值是不被保存的，像水流。
- 因此assign语句中的操作本质上叫做：执行驱动。

#### 2.赋值：

- 寄存器类型的变量是被赋值的，这个值是会被保存的，直到下一次赋值行为到来。
- 因此always语句中的操作本质上叫做：执行赋值。

#### 3.Verilog中的寄存器类型到底是什么：

- 寄存器类型并不对应真正的寄存器，就像上面我们说的一样，寄存器是指在仿真过程中能够保存值的一个真是的物理内存，仅仅是一种描述方式而已。
  - 就像always语句和assign语句，虽然一个对寄存器类型赋值，一个对线网类型赋值，但是在描述组合逻辑的时候，可以产生相同的电路，只是描述方式上有区别而已。
- 只有在时序逻辑中定义的寄存器类型才是物理上的寄存器。

### 十、参数parameter：

- 参数是出现在模块内部的局部常量，而define定义的是整个电路的全局常量。
- 由于参数只定义在一个模块中，因此参数的作用域也是模块。
- 参数一般用来定义位宽或者延时，采用小写形式。
  - ``parameter and_delay = 2``定义了一个与门延时，延时为2个时间单位。

### 十一、系统任务：

- 系统任务相当于C语言中的库函数，这些系统任务统统用于仿真测试。

#### 1.$ display()：

- 用来执行打印操作：

  - ```verilog
    $ display("At time %t " , $ time , "eq0 = 1");
    //$ time是产生模拟时间的系统函数，假设模拟时间是a，最终打印结果：
    //At time a eq0 = 1
    ```

#### 2.$ random()：

- 该系统任务用来返回一个32bit的有符号随机数，该任务在仿真过程中具有重要作用。
